<!doctype html><html lang=en-gb>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<title>Object Equality | Peter Mackay</title>
<meta name=viewport content="width=device-width,minimum-scale=1">
<meta name=description content="Introduction One of the first code smells we encounter when working with an object-oriented language where everything is an object, or everything subclasses a common base class, or there are no static methods, is how OOP typically handles equality of objects.
For value types such as integers and floating point numbers, it&rsquo;s not controversial that we should be able to compare them and decide if they&rsquo;re equal or not. Integers can be compared by bits, and data structures can be compared by descending into the structure and comparing elements.">
<meta name=generator content="Hugo 0.91.2">
<meta name=robots content="noindex, nofollow">
<link rel=stylesheet href=/ananke/css/main.min.css>
<meta property="og:title" content="Object Equality">
<meta property="og:description" content="Introduction One of the first code smells we encounter when working with an object-oriented language where everything is an object, or everything subclasses a common base class, or there are no static methods, is how OOP typically handles equality of objects.
For value types such as integers and floating point numbers, it&rsquo;s not controversial that we should be able to compare them and decide if they&rsquo;re equal or not. Integers can be compared by bits, and data structures can be compared by descending into the structure and comparing elements.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://petmac.dev/posts/object-equality/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-04-01T15:26:29+00:00">
<meta property="article:modified_time" content="2022-04-01T15:26:29+00:00">
<meta itemprop=name content="Object Equality">
<meta itemprop=description content="Introduction One of the first code smells we encounter when working with an object-oriented language where everything is an object, or everything subclasses a common base class, or there are no static methods, is how OOP typically handles equality of objects.
For value types such as integers and floating point numbers, it&rsquo;s not controversial that we should be able to compare them and decide if they&rsquo;re equal or not. Integers can be compared by bits, and data structures can be compared by descending into the structure and comparing elements."><meta itemprop=datePublished content="2022-04-01T15:26:29+00:00">
<meta itemprop=dateModified content="2022-04-01T15:26:29+00:00">
<meta itemprop=wordCount content="2008">
<meta itemprop=keywords content><meta name=twitter:card content="summary">
<meta name=twitter:title content="Object Equality">
<meta name=twitter:description content="Introduction One of the first code smells we encounter when working with an object-oriented language where everything is an object, or everything subclasses a common base class, or there are no static methods, is how OOP typically handles equality of objects.
For value types such as integers and floating point numbers, it&rsquo;s not controversial that we should be able to compare them and decide if they&rsquo;re equal or not. Integers can be compared by bits, and data structures can be compared by descending into the structure and comparing elements.">
</head>
<body class="ma0 avenir bg-near-white">
<header>
<div class=bg-black>
<nav class="pv3 ph3 ph4-ns" role=navigation>
<div class="flex-l justify-between items-center center">
<a href=/ class="f3 fw2 hover-white no-underline white-90 dib">
Peter Mackay
</a>
<div class="flex-l items-center">
<ul class="pl0 mr3">
<li class="list f5 f4-ns fw4 dib pr3">
<a class="hover-white no-underline white-90" href=/posts/ title="Blog Posts page">
Blog Posts
</a>
</li>
</ul>
<div class=ananke-socials>
<a href=https://twitter.com/petmac target=_blank class="twitter ananke-social-link link-transition stackoverflow link dib z-999 pt3 pt0-l mr1" title="Twitter link" rel=noopener aria-label="follow on Twitter——Opens in a new window">
<span class=icon><svg style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167 22.283c-2.619.953-4.274 3.411-4.086 6.101l.063 1.038-1.048-.127c-3.813-.487-7.145-2.139-9.974-4.915l-1.383-1.377-.356 1.017c-.754 2.267-.272 4.661 1.299 6.271.838.89.649 1.017-.796.487-.503-.169-.943-.296-.985-.233-.146.149.356 2.076.754 2.839.545 1.06 1.655 2.097 2.871 2.712l1.027.487-1.215.021c-1.173.0-1.215.021-1.089.467.419 1.377 2.074 2.839 3.918 3.475l1.299.444-1.131.678c-1.676.976-3.646 1.526-5.616 1.568C19.775 43.256 19 43.341 19 43.405c0 .211 2.557 1.397 4.044 1.864 4.463 1.377 9.765.783 13.746-1.568 2.829-1.673 5.657-5 6.978-8.221.713-1.716 1.425-4.851 1.425-6.354.0-.975.063-1.102 1.236-2.267.692-.678 1.341-1.419 1.467-1.631.21-.403.188-.403-.88-.043-1.781.636-2.033.551-1.152-.402.649-.678 1.425-1.907 1.425-2.267.0-.063-.314.042-.671.233-.377.212-1.215.53-1.844.72l-1.131.361-1.027-.7c-.566-.381-1.361-.805-1.781-.932C39.766 21.902 38.131 21.944 37.167 22.283zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg>
</span>
<span class=new-window><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg>
</span></a>
<a href=https://github.com/petmac target=_blank class="github ananke-social-link link-transition stackoverflow link dib z-999 pt3 pt0-l mr1" title="GitHub link" rel=noopener aria-label="follow on GitHub——Opens in a new window">
<span class=icon><svg style="enable-background:new 0 0 512 512" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M256 32C132.3 32 32 134.8 32 261.7c0 101.5 64.2 187.5 153.2 217.9 11.2 2.1 15.3-5 15.3-11.1.0-5.5-.2-19.9-.3-39.1-62.3 13.9-75.5-30.8-75.5-30.8-10.2-26.5-24.9-33.6-24.9-33.6-20.3-14.3 1.5-14 1.5-14 22.5 1.6 34.3 23.7 34.3 23.7 20 35.1 52.4 25 65.2 19.1 2-14.8 7.8-25 14.2-30.7-49.7-5.8-102-25.5-102-113.5.0-25.1 8.7-45.6 23-61.6-2.3-5.8-10-29.2 2.2-60.8.0.0 18.8-6.2 61.6 23.5 17.9-5.1 37-7.6 56.1-7.7 19 .1 38.2 2.6 56.1 7.7 42.8-29.7 61.5-23.5 61.5-23.5 12.2 31.6 4.5 55 2.2 60.8 14.3 16.1 23 36.6 23 61.6.0 88.2-52.4 107.6-102.3 113.3 8 7.1 15.2 21.1 15.2 42.5.0 30.7-.3 55.5-.3 63 0 6.1 4 13.3 15.4 11C415.9 449.1 480 363.1 480 261.7 480 134.8 379.7 32 256 32z"/></svg>
</span>
<span class=new-window><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg>
</span></a>
</div>
</div>
</div>
</nav>
</div>
</header>
<main class=pb7 role=main>
<article class="flex-l flex-wrap justify-between mw8 center ph3">
<header class="mt4 w-100">
<aside class="instapaper_ignoref b helvetica tracked">
BLOG POSTS
</aside>
<div id=sharing class="mt3 ananke-socials">
<a href="https://twitter.com/share?url=https://petmac.dev/posts/object-equality/&text=Object%20Equality" class="ananke-social-link twitter no-underline" aria-label="share on Twitter">
<span class=icon><svg style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167 22.283c-2.619.953-4.274 3.411-4.086 6.101l.063 1.038-1.048-.127c-3.813-.487-7.145-2.139-9.974-4.915l-1.383-1.377-.356 1.017c-.754 2.267-.272 4.661 1.299 6.271.838.89.649 1.017-.796.487-.503-.169-.943-.296-.985-.233-.146.149.356 2.076.754 2.839.545 1.06 1.655 2.097 2.871 2.712l1.027.487-1.215.021c-1.173.0-1.215.021-1.089.467.419 1.377 2.074 2.839 3.918 3.475l1.299.444-1.131.678c-1.676.976-3.646 1.526-5.616 1.568C19.775 43.256 19 43.341 19 43.405c0 .211 2.557 1.397 4.044 1.864 4.463 1.377 9.765.783 13.746-1.568 2.829-1.673 5.657-5 6.978-8.221.713-1.716 1.425-4.851 1.425-6.354.0-.975.063-1.102 1.236-2.267.692-.678 1.341-1.419 1.467-1.631.21-.403.188-.403-.88-.043-1.781.636-2.033.551-1.152-.402.649-.678 1.425-1.907 1.425-2.267.0-.063-.314.042-.671.233-.377.212-1.215.53-1.844.72l-1.131.361-1.027-.7c-.566-.381-1.361-.805-1.781-.932C39.766 21.902 38.131 21.944 37.167 22.283zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg>
</span>
</a>
</div>
<h1 class="f1 athelas mt3 mb1">Object Equality</h1>
<time class="f6 mv4 dib tracked" datetime=2022-04-01T15:26:29Z>April 1, 2022</time>
</header>
<div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h2 id=introduction>Introduction</h2>
<p>One of the first code smells we encounter when working with an object-oriented language where everything is an <em>object</em>, or everything subclasses a common base class, or there are no static methods, is how OOP typically handles equality of objects.</p>
<p>For value types such as integers and floating point numbers, it&rsquo;s not controversial that we should be able to compare them and decide if they&rsquo;re equal or not. Integers can be compared by bits, and data structures can be compared by descending into the structure and comparing elements.</p>
<p>For types passed by reference, such as classes in Java, C#, Swift, Objective-C and so on, it&rsquo;s extremely complicated. Sometimes we care about equality (two reference point to different objects, but those objects contain the same values) and sometimes we care about identity (two references point to the same object.)</p>
<h2 id=properties-of-equatability>Properties of equatability</h2>
<p>There are a few properties of equatability that we can consider to help us recognise whether a language has a good quality equality solution, or not.</p>
<h3 id=equals-expressions-should-be-commutative>Equals expressions should be <em>commutative</em></h3>
<p>That is, &ldquo;is A equal to B?&rdquo; should always evaluate to the same boolean value as &ldquo;is B equal to A?&rdquo; How does that square with a typical OO solution to equality, where you have to compare values like the following snippet?</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift>a.equals(b)
</code></pre></div><p>By giving the left-hand value in the comparison a special role &ndash; i.e., the calculator of the result &ndash; if we were to reverse the order of <code>a</code> and <code>b</code>, we could then be calling the equals method of a completely different type! In that case, there is no guarantee of commutativity.</p>
<p>For this reason, the equals function or operator <em>should not be an instance method</em>. The equality function should be a <em>static method</em> or even a <em>free function</em>.</p>
<h3 id=values-can-only-be-equal-if-they-are-of-the-same-type>Values can only be equal if they are of the same type</h3>
<p>For example, with basic types:</p>
<ul>
<li>Integers of the same width can be compared trivially</li>
<li>Integers of different widths can be compared, if they can be promoted to a larger width</li>
<li>Floating point numbers of the same width can be compared trivially</li>
<li>Single-precision floating point numbers can be compared with double-precision numbers</li>
<li>Integers and floating point numbers can be compared, if the integer can be promoted to a floating point number without loss of precision</li>
</ul>
<p>For more complex types, such as data structures:</p>
<ul>
<li>Two data structures of the same type can be compared fairly trivially by comparing the contents</li>
<li>Two data structures of unrelated types <em>can never</em> be equal</li>
<li>Two data structures of related types can also <em>never</em> be equal, because one type will have data or some other attribute that is missing from the other</li>
</ul>
<p>For this reason, a language should (at compile time) forbid comparisons of incompatible types.</p>
<h3 id=null-references>Null references</h3>
<p>For languages which burden programmers with null references, they have a few properties when compared:</p>
<ul>
<li>Nulls are always equal</li>
<li>A null is never equal to a non-null</li>
<li>Two non-nulls may be equal in terms of reference equality or value equality</li>
</ul>
<p>While these properties are fairly easy to check, requiring the programmer to do it manually results in lots of error-prone boilerplate that will likely be glossed over in code reviews.</p>
<p>Languages should not allow comparisons involving nulls, because the result is always known.</p>
<p>Additionally, languages should automatically generate equality code, in order to reduce boilerplate.</p>
<h2 id=deep-dive-into-c>Deep dive into C#</h2>
<p>Microsoft has documented <a href=https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type>how to define value equality for a class or struct</a>. It&rsquo;s a bit of a wild ride.</p>
<p>I believe Microsoft has somewhat addressed the deficiencies of their initial approach to value equality, with <a href=https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record>Record</a>, but I haven&rsquo;t used C# since <code>Record</code> was introduced.</p>
<p>Long story short, it took Microsoft a long time to identify C# equality as a disaster, and when they did, they had to introduce a completely new type of type to fix it. Ouch!</p>
<p>Anyway, here is the example Microsoft provides for class equality:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TwoDPoint</span> : IEquatable&lt;TwoDPoint&gt;
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> X { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>set</span>; }
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Y { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>set</span>; }

    <span style=color:#66d9ef>public</span> TwoDPoint(<span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y)
    {
        <span style=color:#75715e>// Removed for brevity
</span><span style=color:#75715e></span>    }

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>bool</span> Equals(<span style=color:#66d9ef>object</span> obj) =&gt; <span style=color:#66d9ef>this</span>.Equals(obj <span style=color:#66d9ef>as</span> TwoDPoint);

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> Equals(TwoDPoint p)
    {
        <span style=color:#66d9ef>if</span> (p <span style=color:#66d9ef>is</span> <span style=color:#66d9ef>null</span>)
        {
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
        }

        <span style=color:#75715e>// Optimization for a common success case.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (Object.ReferenceEquals(<span style=color:#66d9ef>this</span>, p))
        {
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
        }

        <span style=color:#75715e>// If run-time types are not exactly the same, return false.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.GetType() != p.GetType())
        {
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
        }

        <span style=color:#75715e>// Return true if the fields match.
</span><span style=color:#75715e></span>        <span style=color:#75715e>// Note that the base class is not invoked because it is
</span><span style=color:#75715e></span>        <span style=color:#75715e>// System.Object, which defines Equals as reference equality.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> (X == p.X) &amp;&amp; (Y == p.Y);
    }

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>int</span> GetHashCode() =&gt; (X, Y).GetHashCode();

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> <span style=color:#66d9ef>operator</span> ==(TwoDPoint lhs, TwoDPoint rhs)
    {
        <span style=color:#66d9ef>if</span> (lhs <span style=color:#66d9ef>is</span> <span style=color:#66d9ef>null</span>)
        {
            <span style=color:#66d9ef>if</span> (rhs <span style=color:#66d9ef>is</span> <span style=color:#66d9ef>null</span>)
            {
                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
            }

            <span style=color:#75715e>// Only the left side is null.
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
        }
        <span style=color:#75715e>// Equals handles case of null on right side.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> lhs.Equals(rhs);
    }

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> <span style=color:#66d9ef>operator</span> !=(TwoDPoint lhs, TwoDPoint rhs) =&gt; !(lhs == rhs);
}
</code></pre></div><p>This class is a container for 8 bytes. We&rsquo;re going to do a <em>lot</em> of work to compare these 8 bytes against another 8 bytes. Let&rsquo;s dig in.</p>
<h3 id=systemobjectequals-override><code>System.Object.Equals</code> override</h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>bool</span> Equals(<span style=color:#66d9ef>object</span> obj) =&gt; <span style=color:#66d9ef>this</span>.Equals(obj <span style=color:#66d9ef>as</span> TwoDPoint);
</code></pre></div><p>To override <code>System.Object.Equals</code>, it appears to be best practice to do a run-time cast of <code>obj</code> to our class type, which will result in either a reference to our class, or reference to a subclass, or a null pointer, and then we pass that into a different, more specific, <code>Equals</code> method to do the work.</p>
<p>As opposed to the call being clear and unambiguous, we rely on language-lawyer knowledge to know which <code>Equals</code> method we&rsquo;re calling into. We&rsquo;re not recursing into the same method again, we&rsquo;re calling a <em>different</em> <code>Equals</code> method.</p>
<p>To paraphrase <a href=https://twitter.com/venkat_s>Dr. Venkat Subramaniam</a>:</p>
<p>Strive to write code which has <em>obviously no problems</em>, rather than code which has <em>no obvious problems.</em></p>
<h3 id=iequatabletequals-implementation><code>IEquatable&lt;T>.Equals</code> implementation</h3>
<p>Acknowledging that <code>System.Object.Equals</code> is terrible, Microsoft provided <em>another</em> equality mechanism: The interface <code>IEquatable&lt;T></code>. This improves on the previous approach by allowing the programmer to constrain the types of object that we can compare equality to. Sounds good, right?</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> Equals(TwoDPoint p)
</code></pre></div><p>We&rsquo;re off to a good start, the function signature has the class we&rsquo;re interested in.</p>
<p>Each implementation has to check that the object passed in is not null. That&rsquo;s not great:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>if</span> (p <span style=color:#66d9ef>is</span> <span style=color:#66d9ef>null</span>)
{
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
}
</code></pre></div><p>Not strictly required, but each implementation <em>should</em> check that the two objects aren&rsquo;t in fact the same object:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#75715e>// Optimization for a common success case.
</span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (Object.ReferenceEquals(<span style=color:#66d9ef>this</span>, p))
{
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
}
</code></pre></div><p>Based on the method signature, we thought we were already talking about two objects of the same type, but that was a trick to keep us on our toes. We need to double-check that neither object has been subclassed:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#75715e>// If run-time types are not exactly the same, return false.
</span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.GetType() != p.GetType())
{
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
}
</code></pre></div><p>Finally, after a dozen lines of boilerplate, we reach the actual comparison:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#75715e>// Return true if the fields match.
</span><span style=color:#75715e>// Note that the base class is not invoked because it is
</span><span style=color:#75715e>// System.Object, which defines Equals as reference equality.
</span><span style=color:#75715e></span><span style=color:#66d9ef>return</span> (X == p.X) &amp;&amp; (Y == p.Y);
</code></pre></div><p>The programmer has to check the individual fields and not make any copy and paste errors. If new fields are added, this code <em>must</em> be updated. That&rsquo;s not ideal, but fairly standard when the compiler cannot generate the comparison code for us.</p>
<p>There is another lurking footgun, where we must be absolutely sure not to call into a base class, or risk infinite recursion, or inadvertently performing reference equality.</p>
<h3 id=systemobjectgethashcode-override><code>System.Object.GetHashCode</code> override</h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>int</span> GetHashCode() =&gt; (X, Y).GetHashCode();
</code></pre></div><p>There&rsquo;s a rule that if two objects are <em>equal</em>, they must also have the same hash code. This is required for correct operation of dictionaries and other collections that use hash codes to optimise lookup. Because we override <code>Equals</code>, we must also override <code>GetHashCode</code>.</p>
<p>It&rsquo;s been a while since I used C#. I wonder does the compiler enforce this requirement?</p>
<p>Again, we access the <code>X</code> and <code>Y</code> fields here, so if any more fields are added, this code should be updated. I say <em>should</em> rather than <em>must</em>, as I understand it&rsquo;s sometimes OK for a hash code to not always use every field. I&rsquo;m not an expert in hashing. I would probably use all fields just to be safe.</p>
<h3 id=-operator><code>==</code> operator</h3>
<p>Microsoft also advises that we implement yet another equality mechanism, the <code>==</code> and <code>!=</code> operators.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> <span style=color:#66d9ef>operator</span> ==(TwoDPoint lhs, TwoDPoint rhs)
{
    <span style=color:#66d9ef>if</span> (lhs <span style=color:#66d9ef>is</span> <span style=color:#66d9ef>null</span>)
    {
        <span style=color:#66d9ef>if</span> (rhs <span style=color:#66d9ef>is</span> <span style=color:#66d9ef>null</span>)
        {
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
        }

        <span style=color:#75715e>// Only the left side is null.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
    }
    <span style=color:#75715e>// Equals handles case of null on right side.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> lhs.Equals(rhs);
}
</code></pre></div><p>We have to write a few lines of easy-to-get-wrong boilerplate, then we call into one of the previous <code>Equals</code> methods to do the tedious work of doing the null checks, the subclassing checks, and finally, comparing the two integers.</p>
<p>What a lot of work, to compare such a small number of bytes.</p>
<h3 id=-operator-1><code>!=</code> operator</h3>
<p>And finally, the language is not clever enough to implement <code>!=</code> for us when we implement <code>==</code>, so it is added manually:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> <span style=color:#66d9ef>operator</span> !=(TwoDPoint lhs, TwoDPoint rhs) =&gt; !(lhs == rhs);
</code></pre></div><h2 id=swift-and-equatable>Swift and <code>Equatable</code></h2>
<p>Swift has an elegant solution to equality. The <a href=https://developer.apple.com/documentation/swift/equatable>Equatable</a> protocol contains the following declaration:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>func</span> == (lhs: <span style=color:#66d9ef>Self</span>, rhs: <span style=color:#66d9ef>Self</span>) -&gt; Bool
</code></pre></div><p>To make your type <em>equatable</em>, you declare that it conforms to the <code>Equatable</code> protocol:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>TwoDPoint</span>: Equatable {
    <span style=color:#66d9ef>let</span> x: Int
    <span style=color:#66d9ef>let</span> y: Int
}
</code></pre></div><p>The protocol has a default implementation of <code>!=</code> that just calls <code>==</code> and negates the result, so you don&rsquo;t need to provide an implementation of both functions.</p>
<p>For value types, the compiler (<a href=https://www.swiftbysundell.com/wwdc2018/synthesized-conditional-conformances-in-swift-42/>since 2018</a>) automatically generates the actual <code>==</code> function for you too, so typically all you need to to is declare that your type is <code>Equatable</code> and you&rsquo;re done.</p>
<p>For classes, you have to write the <code>==</code> function yourself:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TwoDPoint</span> {
    <span style=color:#66d9ef>let</span> x: Int
    <span style=color:#66d9ef>let</span> y: Int

    <span style=color:#66d9ef>init</span>(x: Int, y: Int) {
        <span style=color:#66d9ef>self</span>.x = x
        <span style=color:#66d9ef>self</span>.y = y
    }
}

<span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>TwoDPoint</span>: Equatable {
    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>func</span> == (lhs: TwoDPoint, rhs: TwoDPoint) -&gt; Bool {
        <span style=color:#66d9ef>return</span>
            lhs.x == rhs.x <span style=color:#f92672>&amp;&amp;</span>
            lhs.y == rhs.y
    }
}
</code></pre></div><p>It normally doesn&rsquo;t make sense to compare variables that are not <em>values</em>, and for values you should use a value type such as <code>struct</code> or <code>enum</code>, so if you find yourself hand-implementing <code>==</code> it&rsquo;s time to think about how you got there.</p>
<p>Note there are no null checks in <code>==</code> above. Swift separates the concerns of nullability and references. So by the time your class' <code>==</code> function is called, the null check has already been done.</p>
<h2 id=conclusion>Conclusion</h2>
<p>I hope I&rsquo;ve demonstrated that a typical object-oriented approach to value comparisons quickly gives rise to a whole lot of unnecessary issues. Partly due to being object-oriented, but also due to being overly generic. For example, the C# solution requires that the programmer implement an equality comparison against <em>any other</em> type of object, including nulls, when the 99% <em>actual, concrete use case</em> is that we want to compare <em>non-null values of the same type</em>.</p>
<p>Swift absolutely nails the 99% use case:</p>
<ul>
<li>No boilerplate</li>
<li><code>Equatable</code> only applies to the specific type that&rsquo;s declared conformant</li>
<li>Neither side of the <code>==</code> sign is special</li>
<li>No need to check nulls</li>
<li>Tedious code is automatically generated</li>
</ul>
<p>What wasn&rsquo;t immediately obvious though as we got into the specifics of equality, is that equality is only one basic data transform, and our findings can be extrapolated to cover all kinds of data transforms.</p>
<p>A data transform is when you take more than one source of data, do some work with them, and output some result.</p>
<p>If you want to transform data, and if you&rsquo;re reading this then that is what your job is, then:</p>
<ol>
<li>You should avoid an object-oriented approach, and</li>
<li>you should avoid an overly generic approach, as it will definitely make you solve problems you don&rsquo;t have.</li>
</ol>
<ul class=pa0>
</ul>
<div class="mt6 instapaper_ignoref">
</div>
</div>
<aside class="w-30-l mt6-l"><div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
<p class="f5 b mb3">What's in this post</p>
<nav id=TableOfContents>
<ul>
<li><a href=#introduction>Introduction</a></li>
<li><a href=#properties-of-equatability>Properties of equatability</a>
<ul>
<li><a href=#equals-expressions-should-be-commutative>Equals expressions should be <em>commutative</em></a></li>
<li><a href=#values-can-only-be-equal-if-they-are-of-the-same-type>Values can only be equal if they are of the same type</a></li>
<li><a href=#null-references>Null references</a></li>
</ul>
</li>
<li><a href=#deep-dive-into-c>Deep dive into C#</a>
<ul>
<li><a href=#systemobjectequals-override><code>System.Object.Equals</code> override</a></li>
<li><a href=#iequatabletequals-implementation><code>IEquatable&lt;T>.Equals</code> implementation</a></li>
<li><a href=#systemobjectgethashcode-override><code>System.Object.GetHashCode</code> override</a></li>
<li><a href=#-operator><code>==</code> operator</a></li>
<li><a href=#-operator-1><code>!=</code> operator</a></li>
</ul>
</li>
<li><a href=#swift-and-equatable>Swift and <code>Equatable</code></a></li>
<li><a href=#conclusion>Conclusion</a></li>
</ul>
</nav>
</div>
</aside>
</article>
</main>
<footer class="bg-black bottom-0 w-100 pa3" role=contentinfo>
<div class="flex justify-between">
<a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://petmac.dev/>
&copy; Peter Mackay 2022
</a>
<div>
<div class=ananke-socials>
<a href=https://twitter.com/petmac target=_blank class="twitter ananke-social-link link-transition stackoverflow link dib z-999 pt3 pt0-l mr1" title="Twitter link" rel=noopener aria-label="follow on Twitter——Opens in a new window">
<span class=icon><svg style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167 22.283c-2.619.953-4.274 3.411-4.086 6.101l.063 1.038-1.048-.127c-3.813-.487-7.145-2.139-9.974-4.915l-1.383-1.377-.356 1.017c-.754 2.267-.272 4.661 1.299 6.271.838.89.649 1.017-.796.487-.503-.169-.943-.296-.985-.233-.146.149.356 2.076.754 2.839.545 1.06 1.655 2.097 2.871 2.712l1.027.487-1.215.021c-1.173.0-1.215.021-1.089.467.419 1.377 2.074 2.839 3.918 3.475l1.299.444-1.131.678c-1.676.976-3.646 1.526-5.616 1.568C19.775 43.256 19 43.341 19 43.405c0 .211 2.557 1.397 4.044 1.864 4.463 1.377 9.765.783 13.746-1.568 2.829-1.673 5.657-5 6.978-8.221.713-1.716 1.425-4.851 1.425-6.354.0-.975.063-1.102 1.236-2.267.692-.678 1.341-1.419 1.467-1.631.21-.403.188-.403-.88-.043-1.781.636-2.033.551-1.152-.402.649-.678 1.425-1.907 1.425-2.267.0-.063-.314.042-.671.233-.377.212-1.215.53-1.844.72l-1.131.361-1.027-.7c-.566-.381-1.361-.805-1.781-.932C39.766 21.902 38.131 21.944 37.167 22.283zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg>
</span>
<span class=new-window><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg>
</span></a>
<a href=https://github.com/petmac target=_blank class="github ananke-social-link link-transition stackoverflow link dib z-999 pt3 pt0-l mr1" title="GitHub link" rel=noopener aria-label="follow on GitHub——Opens in a new window">
<span class=icon><svg style="enable-background:new 0 0 512 512" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M256 32C132.3 32 32 134.8 32 261.7c0 101.5 64.2 187.5 153.2 217.9 11.2 2.1 15.3-5 15.3-11.1.0-5.5-.2-19.9-.3-39.1-62.3 13.9-75.5-30.8-75.5-30.8-10.2-26.5-24.9-33.6-24.9-33.6-20.3-14.3 1.5-14 1.5-14 22.5 1.6 34.3 23.7 34.3 23.7 20 35.1 52.4 25 65.2 19.1 2-14.8 7.8-25 14.2-30.7-49.7-5.8-102-25.5-102-113.5.0-25.1 8.7-45.6 23-61.6-2.3-5.8-10-29.2 2.2-60.8.0.0 18.8-6.2 61.6 23.5 17.9-5.1 37-7.6 56.1-7.7 19 .1 38.2 2.6 56.1 7.7 42.8-29.7 61.5-23.5 61.5-23.5 12.2 31.6 4.5 55 2.2 60.8 14.3 16.1 23 36.6 23 61.6.0 88.2-52.4 107.6-102.3 113.3 8 7.1 15.2 21.1 15.2 42.5.0 30.7-.3 55.5-.3 63 0 6.1 4 13.3 15.4 11C415.9 449.1 480 363.1 480 261.7 480 134.8 379.7 32 256 32z"/></svg>
</span>
<span class=new-window><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg>
</span></a>
</div></div>
</div>
</footer>
</body>
</html>