<!doctype html><html lang=en-gb><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>PC Engine tile-based quantisation | Peter Mackay</title>
<meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Introduction
I spend some time in the evenings working on various toy projects. It&rsquo;s a good way to exercise a programmer brain in a way that a day job generally doesn&rsquo;t.
Anyway, a while back I bought an Analogue Duo, which is a high quality FPGA clone of the old 8/16-bit PC Engine console.
I say 8/16 rather than just 16-bit, because while the GPU was 16-bit, the CPU was an 8-bit HuC6280 &ndash; a derivative of the legendary 6502 CPU, with a bunch of handy extra instructions and so on. Oh, and 4 times the typical speed."><meta name=generator content="Hugo 0.140.1"><meta name=robots content="index, follow"><link rel=stylesheet href=/ananke/css/main.min.59ce02eddf15260b506a9352ecc773e6fa3df2f9f2c2f46cd1ed6c8c90355170.css><link rel=canonical href=https://petmac.dev/posts/pce-quant/><meta property="og:url" content="https://petmac.dev/posts/pce-quant/"><meta property="og:site_name" content="Peter Mackay"><meta property="og:title" content="PC Engine tile-based quantisation"><meta property="og:description" content="Introduction I spend some time in the evenings working on various toy projects. It’s a good way to exercise a programmer brain in a way that a day job generally doesn’t.
Anyway, a while back I bought an Analogue Duo, which is a high quality FPGA clone of the old 8/16-bit PC Engine console.
I say 8/16 rather than just 16-bit, because while the GPU was 16-bit, the CPU was an 8-bit HuC6280 – a derivative of the legendary 6502 CPU, with a bunch of handy extra instructions and so on. Oh, and 4 times the typical speed."><meta property="og:locale" content="en_gb"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-06-03T22:20:39+01:00"><meta property="article:modified_time" content="2024-06-03T22:20:39+01:00"><meta itemprop=name content="PC Engine tile-based quantisation"><meta itemprop=description content="Introduction I spend some time in the evenings working on various toy projects. It’s a good way to exercise a programmer brain in a way that a day job generally doesn’t.
Anyway, a while back I bought an Analogue Duo, which is a high quality FPGA clone of the old 8/16-bit PC Engine console.
I say 8/16 rather than just 16-bit, because while the GPU was 16-bit, the CPU was an 8-bit HuC6280 – a derivative of the legendary 6502 CPU, with a bunch of handy extra instructions and so on. Oh, and 4 times the typical speed."><meta itemprop=datePublished content="2024-06-03T22:20:39+01:00"><meta itemprop=dateModified content="2024-06-03T22:20:39+01:00"><meta itemprop=wordCount content="2288"><meta name=twitter:card content="summary"><meta name=twitter:title content="PC Engine tile-based quantisation"><meta name=twitter:description content="Introduction I spend some time in the evenings working on various toy projects. It’s a good way to exercise a programmer brain in a way that a day job generally doesn’t.
Anyway, a while back I bought an Analogue Duo, which is a high quality FPGA clone of the old 8/16-bit PC Engine console.
I say 8/16 rather than just 16-bit, because while the GPU was 16-bit, the CPU was an 8-bit HuC6280 – a derivative of the legendary 6502 CPU, with a bunch of handy extra instructions and so on. Oh, and 4 times the typical speed."></head><body class="ma0 avenir bg-near-white production"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">Peter Mackay</a><div class="flex-l items-center"><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/posts/ title="Blog Posts page">Blog Posts</a></li></ul><div class=ananke-socials><a href=https://bsky.app/profile/petmac.bsky.social target=_blank rel=noopener class="ananke-social-link link-transition bluesky link dib z-999 pt3 pt0-l mr1" title="follow on Bluesky - Opens in a new window" aria-label="follow on Bluesky - Opens in a new window"><span class=icon><svg viewBox="0 0 576 512"><path d="M407.8 294.7c-3.3-.4-6.7-.8-10-1.3 3.4.4 6.7.9 10 1.3zM288 227.1C261.9 176.4 190.9 81.9 124.9 35.3 61.6-9.4 37.5-1.7 21.6 5.5 3.3 13.8.0 41.9.0 58.4S9.1 194 15 213.9c19.5 65.7 89.1 87.9 153.2 80.7 3.3-.5 6.6-.9 10-1.4-3.3.5-6.6 1-10 1.4-93.9 14-177.3 48.2-67.9 169.9C220.6 589.1 265.1 437.8 288 361.1c22.9 76.7 49.2 222.5 185.6 103.4 102.4-103.4 28.1-156-65.8-169.9-3.3-.4-6.7-.8-10-1.3 3.4.4 6.7.9 10 1.3 64.1 7.1 133.6-15.1 153.2-80.7C566.9 194 576 75 576 58.4s-3.3-44.7-21.6-52.9c-15.8-7.1-40-14.9-103.2 29.8C385.1 81.9 314.1 176.4 288 227.1z"/></svg>
</span></a><a href=https://github.com/petmac/ target=_blank rel=noopener class="ananke-social-link link-transition github link dib z-999 pt3 pt0-l mr1" title="follow on GitHub - Opens in a new window" aria-label="follow on GitHub - Opens in a new window"><span class=icon><svg viewBox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
</span></a><a href=https://mastodon.gamedev.place/@petmac target=_blank rel=noopener class="ananke-social-link link-transition mastodon link dib z-999 pt3 pt0-l mr1" title="follow on Mastodon - Opens in a new window" aria-label="follow on Mastodon - Opens in a new window"><span class=icon><svg viewBox="0 0 448 512"><path d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48.0.0.0-63.72 28.5-63.72 125.7.0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.54 102.54.0 01-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5zm-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"/></svg>
</span></a><a href=https://twitter.com/petmac target=_blank rel=noopener class="ananke-social-link link-transition twitter link dib z-999 pt3 pt0-l mr1" title="follow on Twitter - Opens in a new window" aria-label="follow on Twitter - Opens in a new window"><span class=icon><svg viewBox="0 0 512 512"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645.0 138.72-105.583 298.558-298.558 298.558-59.452.0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055.0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421.0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391.0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04.0-57.828 46.782-104.934 104.934-104.934 30.213.0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg></span></a></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked ttu">Blog Posts</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">PC Engine tile-based quantisation</h1><time class="f6 mv4 dib tracked" datetime=2024-06-03T22:20:39+01:00>June 3, 2024</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h2 id=introduction>Introduction</h2><p>I spend some time in the evenings working on various toy projects. It&rsquo;s a good way to exercise a programmer brain in a way that a day job generally doesn&rsquo;t.</p><p>Anyway, a while back I bought an <a href=https://www.analogue.co/duo>Analogue Duo</a>, which is a high quality FPGA clone of the old 8/16-bit <a href=https://en.wikipedia.org/wiki/TurboGrafx-16>PC Engine</a> console.</p><p>I say 8/16 rather than just 16-bit, because while the GPU was 16-bit, the CPU was an 8-bit <a href=https://en.wikipedia.org/wiki/Hudson_Soft_HuC6280>HuC6280</a> &ndash; a derivative of the legendary 6502 CPU, with a bunch of handy extra instructions and so on. Oh, and 4 times the typical speed.</p><p>The PC Engine also had a CD-ROM expansion, which allowed plenty of storage. An almost unimaginable amount for the time.</p><h2 id=pc-engine-graphics>PC Engine graphics</h2><p>The PC Engine&rsquo;s graphics were powered by the 16-bit <a href=https://en.wikipedia.org/wiki/Hudson_Soft_HuC6270>HuC6270</a>. The PC Engine was released shortly after the NES, and it&rsquo;s fair to describe its graphics capability as somewhere between the NES and Mega Drive.</p><p>Crucially, it&rsquo;s a tile-based system, where each tile is an 8x8 pixel pattern.</p><p>Tiles can use colours from any one palette out of the 16 background colour palettes, where each palette has 16 colours.</p><p>Each colour has a 3-bit red component, 3-bit green component, and 3-bit blue component, which gives rise to 512 possible colours.</p><p>There are 16 additional palettes just for sprites, but we&rsquo;ll ignore those.</p><p>That means up to 256 unique colours on screen, just for the background.</p><p>There&rsquo;s a Background Attribute Table (&ldquo;BAT&rdquo;) at the start of VRAM, which describes which pattern is used for each of on-screen tiles. The BAT also describes which of the 16 palettes is assigned to each on-screen tile.</p><p>Since the palette indices are in the BAT rather than in the patterns, you could do the infamous Super Mario Bros. trick, where the clouds and bushes use the same tile patterns, just with different palettes.</p><p>To summarise:</p><ul><li>16 palettes, each with 16 colours.</li><li>8x8 tiles, and each tile can use any palette.</li><li>3-bit colour depth.</li></ul><h2 id=motivation>Motivation</h2><p>I come from an Amiga background, where every on-screen colour has to be bought with compromises. Additionally, with Amiga disks being only 880 KB and hard drives not being standard for the platform, there wasn&rsquo;t much storage for graphics.</p><p>So, with up to 256 colours available for the background, and lots of storage on CD-ROM, why did many PC Engine CD games look&mldr; quite bad? They tended to use few colours, and the edges of tiles were very obvious.</p><p>Maybe there were limitations I hadn&rsquo;t considered? (Spoiler: Yes)</p><p>I set out to find out how good a PC Engine background could theoretically look. And by that, I mean using lots of colours, and lots of unique detail.</p><h2 id=problem>Problem</h2><p>The problem I wanted to solve was, to take an input image, convert it to tiles, select the best 16 palettes for the image, and write out the image as it would look on PC Engine.</p><p>I chose <a href=https://www.mobygames.com/game/858/final-fantasy-vii/screenshots/playstation/397288/>this image of Final Fantasy VII from MobyGames</a>, for a few reasons:</p><ol><li>It&rsquo;s fairly low resolution, like the PC Engine</li><li>It&rsquo;s from a 32-bit console, setting a high bar for success</li><li>It uses loads of unique colours</li><li>There are subtle gradients</li><li>There are small areas with contrasting colours, such as around the characters</li></ol><p><img src=input.png alt="Final Fantasy VII (PlayStation) screenshot"></p><h2 id=existing-tools>Existing tools</h2><p>There&rsquo;s an excellent online tool which does this kind of image processing:</p><p><a href=https://rilden.github.io/tiledpalettequant/>https://rilden.github.io/tiledpalettequant/</a></p><p>Given an input image, it will generate an image with these kind of constraints &ndash; tiles, palettes, low bits per channel.</p><p>The output image from the website isn&rsquo;t ready to use for any platform, so another tool would be required to convert the output to be usable on your platform of choice.</p><p>To match PC Engine specs, I changed some of the settings from defaults:</p><ul><li>Change Palettes from 8 to 16</li><li>Change Colors per palette from 4 to 16</li><li>Change Bits per channel from 5 to 3</li></ul><p>Then, to improve the quality of the output:</p><ul><li>Change Dithering from &ldquo;disabled&rdquo; to &ldquo;slow&rdquo;</li></ul><p>For comparison, here&rsquo;s the input image again, the quantized image generated by tiledpalettequant, and the generated palettes packed into an image:</p><p>Input image:</p><p><img src=input.png alt="Input image"></p><p>Image and palettes generated by tiledpalettequant:</p><p><img src=input-8x8-16p16c-u.png alt="Image generated by tiledpalettequant"> <img src=input-8x8-16p16c-u-palette.png alt="Palettes generated by tiledpalettequant"></p><p>The site does (in my opinion) an incredible job. Aside from the gradients at the bottom of the image, you would barely know it had been through such processing. I could have called it a day, but it&rsquo;s an interesting problem and I wanted to dive deeper.</p><p>I didn&rsquo;t like the dithering pattern all that much as I find the halftone pattern is quite visible. I think it&rsquo;s just too regular.</p><p>Some kind of dithering is required, as the 3-bit colour limitation is quite brutal. I wanted to experiment with an error diffusion-type of dithering.</p><p>Additionally I like command line tools so I can plumb them into a build process. A web-based tool doesn&rsquo;t really appeal to me.</p><p>The website also took about a minute to process the image, which was surprising.</p><p>I also really wanted to see the resulting image on a PC Engine/Analogue Duo or emulator.</p><p>So I wrote my own tool.</p><h2 id=chosen-technology-rust>Chosen technology: Rust</h2><p>I&rsquo;m a big fan of Rust for command line tools. There&rsquo;s a large ecosystem of packages (&ldquo;crates&rdquo;), and with Cargo there&rsquo;s no hassle integrating dependencies, you can get on with solving the problem at hand.</p><p>Some people don&rsquo;t like the Rust syntax, or the borrow checker, but I find that I rarely need to annotate lifetimes or types, and for tools with clear inputs and outputs, the borrow checker rarely gets in the way.</p><p>This isn&rsquo;t meant to be a Rust versus <em>whatever</em> post, so I&rsquo;ll leave it at that.</p><h2 id=general-algorithm>General algorithm</h2><p>There might be a better way to do it, but I sketched out the following algorithm in <code>main()</code> and started implementing it:</p><ol><li>Load true-colour image</li><li>Cut image into tile patterns</li><li>Find tiles with similar colours and group into 16 groups</li><li>For each group of tiles, find the palette which best fits the tiles in the group</li><li>For each true-colour tile, remap to the nearest colour in the palette (and dither)</li></ol><h2 id=loading-and-cutting-the-image-into-tiles>Loading and cutting the image into tiles</h2><p>The first couple of steps in the general algorithm are fairly straightforward and not worh discussing in detail. I used the <code>png</code> crate to load the input image, and some <code>for</code> loops to iterate through the image data and store it in <code>Tile</code> structures.</p><p>I tried a bit to do it in a more elegant way, using <a href=https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_exact><code>chunks_exact()</code></a> and so on, but I never found an implementation that was as neat and tidy as just doing the <code>for</code> loops.</p><p>I won&rsquo;t paste it here, for fear of embarrassment!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ColorU8</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> r: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> g: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> b: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>TILE_SIZE</span>: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>TiledImage</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> width_in_tiles: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> height_in_tiles: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> tiles: Vec<span style=color:#f92672>&lt;</span>Tile<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Tile</span> <span style=color:#f92672>=</span> [[ColorU8; <span style=color:#66d9ef>TILE_SIZE</span>]; <span style=color:#66d9ef>TILE_SIZE</span>];
</span></span></code></pre></div><p>For clarity, the colours at this point are 8-bit true colour, rather than 3-bit, in order to avoid any rounding errors. Maybe it would be better to get the rounding over and done with early rather than late, but that&rsquo;s not how I approached it.</p><h2 id=attempt-1-average-colour-per-tile-and-colour-space-partitioning>Attempt 1: average colour per tile and colour space partitioning</h2><h3 id=grouping-similar-tiles>Grouping similar tiles</h3><p>I had the idea of grouping similar tiles by computing the average colour for every tile, then building a <a href=https://en.wikipedia.org/wiki/Frequency_(statistics)>frequency distribution</a> of those average colours, which is effectely a count of occurrences of each unique colour.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ColorDistribution</span> {
</span></span><span style=display:flex><span>    color_pixel_counts: <span style=color:#a6e22e>BTreeMap</span><span style=color:#f92672>&lt;</span>ColorU8, <span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The big drawback of this approach is that taking the average colour of each tile loses an awful lot of information about the range of colours in that tile.</p><p>I would then try to partition the distribution of average colours into 16 convex cells. Each cell would share the same palette.</p><p>The partitioning algorithm centred around the concept of a <a href=https://en.wikipedia.org/wiki/Binary_space_partitioning>BSP tree</a>, where each leaf was a colour distribution.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>BspTree</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> leaves: Vec<span style=color:#f92672>&lt;</span>ColorDistribution<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I repeatedly picked the leaf with the largest number of colour occurrences, and split that leaf into 2 further leaves, until the total number of leaves reached 16, or the leaves couldn&rsquo;t be split any further.</p><p>To split a leaf, I computed the colour distribution component (red, green, or blue) with the largest range, the average colour of the leaf, and for each colour in the starting leaf, if the component was greater than average then it went in one new leaf, and if it was less, then it went in the other new leaf.</p><p>The result of all of that work was just 16 colours. For each tile, I then chose which of those colours was closest to the average colour of that tile, and that would be ideally be representative of the palette the tile should use.</p><h3 id=generating-palettes-for-tiles>Generating palettes for tiles</h3><p>Now that I&rsquo;ve grouped &ldquo;similar&rdquo; tiles, I repeated the process to generate a palette for each group.</p><p>I took all of the pixel colours in each tile group, and computed another colour distribution. I again reduced each colour distribution down to 16 colours, and that would be the palette shared by the tiles in the group.</p><p>The result was 16 palettes of 16 colours, and a list of the tiles used by each palette.</p><p>For each tile, I then did a remapping of true colours to the nearest colour in the tile&rsquo;s palette. The result was something like this:</p><p><img src=bsp-3bit.png alt="Image generated by tiledpalettequant"></p><p>I was quite encouraged that the overall algorithm was successful, but two things really bothered me:</p><p>First, when grouping similar tiles, a huge amount of information was thrown away by taking the average colour per tile. I felt this was most noticeable in areas with saturated colour, such as the characters standing on the walkway. Where did the vibrant red and orange go?</p><p>The second thing that bothered me was the colour space partitioning algorithm, and how it only split the space into axis-aligned regions. Other than that, I was quite happy with the BSP approach.</p><h2 id=attempt-2-k-means-clustering>Attempt 2: k-means clustering</h2><p>While I was impressed that someone with no experience in quantisation could just dive in and get decent results, I did some more investigation into the algorithms that &ldquo;proper&rdquo; paint packages use for this kind of processing.</p><p>I found <a href=https://en.wikipedia.org/wiki/K-means_clustering><em>k</em>-means clustering</a>.</p><blockquote><p><em>k</em>-means clustering is a method of vector quantization &mldr; to partition <em>n</em> observations into <em>k</em> clusters &mldr;</p></blockquote><p>Well that sounded just like what I was trying to do. And there was a <a href=https://crates.io/crates/clustering><code>clustering</code></a> crate which implemented this algorithm in a reusable way.</p><p>The crate&rsquo;s <code>kmeans()</code> function accepts a constant <em>k</em> (the maximum number of clusters to generate), a list of <em>elements</em> to cluster, and a maximum number of <em>iterations</em> to run.</p><p>There were two types of clustering I was trying to do:</p><ol><li>Clustering similar tiles</li><li>Clustering colours inside tile clusters</li></ol><p>Each element is a vector of floating point numbers, so to cluster something, you need to represent it as a vector of some kind. For colours, a 3D red-green-blue works just fine, but for more complex elements, some other representation is needed.</p><p>To cluster similar tiles, I chose a vector of 6 values:</p><ul><li>Minimum red, green, and blue values</li><li>Maximum red, green, and blue values</li></ul><p>This representation seemed horribly basic, but not nearly so much as just clustering by the average colour. I figured it would capture the range of colours more effectively.</p><p>To cluster similar colours to generate a palette, I used the RGB components directly.</p><p>The result was quite impressive compared to my previous approach:</p><p><img src=remapped-3bit.png alt="Image generated when using clustering crate"></p><p>Note that the vibrant colours had returned, and the edges of tiles weren&rsquo;t nearly so visible.</p><p>There was still quite bad banding though, brought on by the 3-bit colour depth.</p><h2 id=dithering>Dithering</h2><p>I implemented my own custom error-diffusion dithering method, where during the remapping phase (choosing pixel colours from an existing palette), I track the &ldquo;error&rdquo; (difference between the ideal colour and chosen colour) and try to correct some of that error when remapping the next pixel, by applying part of the error as a bias.</p><p>I didn&rsquo;t think that was particularly novel, so I won&rsquo;t go into more detail, but the end result worked pretty well:</p><p><img src=remapped-3bit-dither-improved.png alt="Image with dithering"></p><h2 id=testing-in-an-emulator>Testing in an emulator</h2><p>Emboldened by my success, I felt that PC Engine games <em>could</em> have looked much better than they did, so why didn&rsquo;t they?</p><p>I spent a long time learning how to program PC Engine things.</p><p>I modified my converter to dump out the image in a format that a PC Engine game could load into VRAM.</p><p>The data was quite large, using most of the 64K of VRAM that was available. I started to get nervous.</p><p>I then wrote a PC Engine CD program in <a href=https://github.com/pce-devel/huc>HuC</a> that loaded the data from CD into VRAM. I felt CD was the way to go, as <a href=https://en.wikipedia.org/wiki/HuCard>HuCards</a> are quite limited in size.</p><p>To my disappointment, it took about 6 seconds to load the data from CD. I guess there&rsquo;s no fast channel from CD to VRAM.</p><h2 id=conclusion>Conclusion</h2><p>I really enjoyed this hobby project. I found that PC Engine games left a lot of image quality on the table, but it wasn&rsquo;t without reason.</p><h2 id=future-work>Future work</h2><p>I wonder if I could reduce the number of unique tile patterns, could I shrink the size of the data in VRAM? Perhaps some of the tiles are so similar that they could share patterns.</p><p>Perhaps the tool could be adapted and used for other platforms with more memory, or faster transfer speeds, such as Mega Drive or SNES.</p><h2 id=bonus>Bonus</h2><p>To show why dithering was needed, here&rsquo;s the converter outputting an image with 8-bit colour rather than 3-bit:</p><p><img src=remapped-8bit.png alt="Image showing how much better 8-bit colour looks"></p><p>You would barely know it was reduced to 16 palettes of 16 colours.</p><p>I added a fun debug toggle to the converter, so I could see which tiles used which palette:</p><p><img src=tiles-palettes-3bit.png alt="Image showing the palette used by each tile"></p><ul class=pa0></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"><div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links"><p class="f5 b mb3">What's in this post</p><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#pc-engine-graphics>PC Engine graphics</a></li><li><a href=#motivation>Motivation</a></li><li><a href=#problem>Problem</a></li><li><a href=#existing-tools>Existing tools</a></li><li><a href=#chosen-technology-rust>Chosen technology: Rust</a></li><li><a href=#general-algorithm>General algorithm</a></li><li><a href=#loading-and-cutting-the-image-into-tiles>Loading and cutting the image into tiles</a></li><li><a href=#attempt-1-average-colour-per-tile-and-colour-space-partitioning>Attempt 1: average colour per tile and colour space partitioning</a><ul><li><a href=#grouping-similar-tiles>Grouping similar tiles</a></li><li><a href=#generating-palettes-for-tiles>Generating palettes for tiles</a></li></ul></li><li><a href=#attempt-2-k-means-clustering>Attempt 2: k-means clustering</a></li><li><a href=#dithering>Dithering</a></li><li><a href=#testing-in-an-emulator>Testing in an emulator</a></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#future-work>Future work</a></li><li><a href=#bonus>Bonus</a></li></ul></nav></div></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://petmac.dev/>&copy; Peter Mackay 2024</a><div><div class=ananke-socials><a href=https://bsky.app/profile/petmac.bsky.social target=_blank rel=noopener class="ananke-social-link link-transition bluesky link dib z-999 pt3 pt0-l mr1" title="follow on Bluesky - Opens in a new window" aria-label="follow on Bluesky - Opens in a new window"><span class=icon><svg viewBox="0 0 576 512"><path d="M407.8 294.7c-3.3-.4-6.7-.8-10-1.3 3.4.4 6.7.9 10 1.3zM288 227.1C261.9 176.4 190.9 81.9 124.9 35.3 61.6-9.4 37.5-1.7 21.6 5.5 3.3 13.8.0 41.9.0 58.4S9.1 194 15 213.9c19.5 65.7 89.1 87.9 153.2 80.7 3.3-.5 6.6-.9 10-1.4-3.3.5-6.6 1-10 1.4-93.9 14-177.3 48.2-67.9 169.9C220.6 589.1 265.1 437.8 288 361.1c22.9 76.7 49.2 222.5 185.6 103.4 102.4-103.4 28.1-156-65.8-169.9-3.3-.4-6.7-.8-10-1.3 3.4.4 6.7.9 10 1.3 64.1 7.1 133.6-15.1 153.2-80.7C566.9 194 576 75 576 58.4s-3.3-44.7-21.6-52.9c-15.8-7.1-40-14.9-103.2 29.8C385.1 81.9 314.1 176.4 288 227.1z"/></svg>
</span></a><a href=https://github.com/petmac/ target=_blank rel=noopener class="ananke-social-link link-transition github link dib z-999 pt3 pt0-l mr1" title="follow on GitHub - Opens in a new window" aria-label="follow on GitHub - Opens in a new window"><span class=icon><svg viewBox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
</span></a><a href=https://mastodon.gamedev.place/@petmac target=_blank rel=noopener class="ananke-social-link link-transition mastodon link dib z-999 pt3 pt0-l mr1" title="follow on Mastodon - Opens in a new window" aria-label="follow on Mastodon - Opens in a new window"><span class=icon><svg viewBox="0 0 448 512"><path d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48.0.0.0-63.72 28.5-63.72 125.7.0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.54 102.54.0 01-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5zm-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"/></svg>
</span></a><a href=https://twitter.com/petmac target=_blank rel=noopener class="ananke-social-link link-transition twitter link dib z-999 pt3 pt0-l mr1" title="follow on Twitter - Opens in a new window" aria-label="follow on Twitter - Opens in a new window"><span class=icon><svg viewBox="0 0 512 512"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645.0 138.72-105.583 298.558-298.558 298.558-59.452.0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055.0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421.0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391.0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04.0-57.828 46.782-104.934 104.934-104.934 30.213.0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg></span></a></div></div></div></footer></body></html>